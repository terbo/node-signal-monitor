#!/usr/bin/env node
'use strict'

require('console-stamp')(console, { pattern: 'HH:MM:ss' })

var cfg  = require('../etc/config')

const fs       = require('fs'),
      os       = require('os'),
      WS       = require('ws'),
      path     = require('path'),
      decycle = require('json-cyclic').decycle,
      process  = require('process'),
      program  = require('commander')

module.paths.unshift(path.join(cfg.baseDir, 'lib'))

const utils         = require('sigmon.utils'),
      store         = require('db.nedb'),
      getVendor     = utils.getVendor,
      getDuration   = utils.getDuration,
      Sensor        = require('device.sensor').Sensor,
      wifiDevice    = require('device.wifiv2').wifiDevice,
      rtlDevice     = require('device.sdr').rtlDevice,
      deviceSession = require('device.session').deviceSession,
      cleanup  = utils.Cleanup

program.name('sigmon websocket server')
       .version(cfg.version)
       .description('sigmon websocket server')
       .option('-p, --port <port>','port to listen on',cfg.ws.port)
       .option('-l, --host <ip>','ip to bind to',cfg.ws.hostname)
       .option('-v, --verbose', 'verbose output', cfg.server.verbose)
       .option('-i, --sync-interval <millisecs>','time between db syncs',cfg.db.sync_interval)
       .option('-c, --compact-interval <millisecs>','time between db compaction', cfg.db.compact_interval)
       .option('-d, --dbfile <file>','json database file to use', path.join(cfg.baseDir, 'data', cfg.db.file))
       .option('-D, --debug', 'enable debugging output', cfg.server.debug)
       .option('-m,--oui-file <file>','Specify the OUI JSON database',path.join(cfg.baseDir, 'data', cfg.oui.file))
       //.option('-U,--update-oui','Manually update the IEEE OUI registry')

program.parse(process.argv)

var data = {
  clients: {},
  sensors: {},
  channels: [],
  db: {},

  devs: { ap: [], sta: [], ssid: [], vendors: [], rtl: [] },

  location: { lon: 0, lat: 0, sats: 0 },

  stats: { packets: 0, errors: 0, cpu: 0, dbsize: 0, rtl: 0,
           memory: 0, aps: 0, ssids: 0, stas: 0, vendors: 0,
           runtime: 0 },

  info: { uptime: os.uptime(), start_time: new Date(), port: program.port,
          user: os.userInfo(), pid: process.pid, version: program.version(),
          hostname: os.hostname(), versions: process.versions, debug: cfg.server.debug
        },
  config: cfg.server,
},

  syncTimer = null

const logger = require('logger.js')
var log = logger.log,
  error = logger.error,
  debug = logger.debug,
  lastlog = logger.lastlog

if(program.verbose)
  logger.verbose()

log(`Loading Signal Monitor version ${data.info.version} on ${data.info.hostname}`)

if(cfg.db.enabled) {
  log(`Devices: Owned: ${Object.keys(cfg.devices.owned).length} Ignore: ${Object.keys(cfg.devices.ignore).length}` +
      ` Alert: ${Object.keys(cfg.devices.alert).length} Track: ${Object.keys(cfg.devices.track).length}`)
  log(`Saving: Unfamiliar: ${cfg.device.prune_unfamiliar} Unknown: ${cfg.device.prune_unknowns} AP: ${cfg.device.prune_aps}` +
      ` Clients: ${cfg.device.prune_clients}`)
  log(`Syncing every ${cfg.db.sync_interval / 1000} seconds.`)

  store.load(program.dbfile)

  //var start_read = new Date()

  store.read((err, docs) => {
    if(err) {
      error(err);
      program.exit(2);
    }

    docs.forEach(doc => {
      data.db[doc.mac] = new wifiDevice(false, doc)
      // now handled above
      //data.db[doc.mac].sessions = new deviceSession(false, doc.sessions.sessions)

      if(doc.type == 'ap') data.devs.ap.push(doc.mac)
      else if(doc.type == 'sta') data.devs.sta.push(doc.mac)
      if(!data.devs.ssid.includes(doc.ssid)) data.devs.ssid.push(doc.ssid)
    })

    //var end_read = new Date()

    log(`Loaded ${Object.keys(data.db).length} devices`)
    // somehow this still misses a few dozen of the first packets sent
    // before it loads data.db ... but it probably merges them.. i think?
  })

  //store.on('compaction.done', () => { debug('compacting done') })
}

function updateStats() {
  data.stats.dbsize = fs.statSync(path.join(cfg.baseDir, 'data', cfg.db.file)).size
  data.stats.aps = data.devs.ap.length
  data.stats.ssids = data.devs.ssid.length
  data.stats.stas = data.devs.sta.length
  data.stats.vendors = data.devs.vendors.length

  data.stats.cpu = process.cpuUsage()
  data.stats.memory = process.memoryUsage()

  data.stats.runtime = getDuration((new Date().getTime() - new Date(data.info.start_time).getTime())) || 'wot?'
  data.stats.uptime = getDuration(os.uptime() * 1000)

  if(data.config != cfg.server)
    data.config = cfg.server
}

// I want to do new wifiRecord or something, and put in seperate library
function newWifiDevice(packet) {
  var newdev = new wifiDevice(packet)

  if(newdev.type == 'ap') {
      log(`+ AP '${newdev.ssid}' from ${packet.sensor} type ${newdev.vendorSm} chan ${newdev.channel} rssi ${newdev.rssi}`)
  } else if(newdev.type == 'sta') {
      log(`+ Probe '${newdev.macSm}' for '${newdev.ssid}' from ${packet.sensor} type ${newdev.vendorSm} rssi ${newdev.lastrssi} seq ${newdev.seq}`)
      newdev.hosts.push(newdev.ssid)
  }

  if(!data.devs[newdev.type].includes(newdev.mac))
    data.devs[newdev.type].push(newdev.mac)

  if(!data.devs.ssid.includes(newdev.ssid))
    data.devs.ssid.push(newdev.ssid)

  if(newdev.vendor != 'Unknown' && (!data.devs.vendors.includes(newdev.vendor)))
    data.devs.vendors.push(newdev.vendor)

  return newdev
}

function readWifiPacket(msg, id) {
  const now = new Date()

  try {
    var packet = msg.data,
        sensor = packet.sensor

    data.location = msg.location

    if(!data.sensors.hasOwnProperty(sensor)) {
      log(`New sensor: ${sensor} at ${id}`)
      data.clients[id].name = sensor
      data.sensors[sensor] = new Sensor(packet)
      data.sensors[sensor].id = id
    }
    else
      data.sensors[sensor].update(packet)

    if(!data.devs[packet.type].includes(packet.mac))
      data.db[packet.mac] = newWifiDevice(packet)

    /*else {
      if(data.devs.ap.includes(packet.src)) {
        packet.mac = packet.dst
        packet.ssid = data.db[packet.src].ssid

        if(!data.db[packet.src].hosts.includes(packet.dst)) {
          data.db[packet.src].hosts.push(packet.dst)

          if(!data.db.hasOwnProperty(packet.dst))
            data.db[packet.dst] = newWifiDevice(packet)
        }
      } else
        if (data.devs.ap.includes(packet.dst)) {
          packet.mac = packet.src
          packet.ssid = data.db[packet.dst].ssid

          if(!data.db[packet.dst].hosts.includes(packet.src)) {
            data.db[packet.dst].hosts.push(packet.src)

            if(!data.db.hasOwnProperty(packet.src))
              data.db[packet.src] = newWifiDevice(packet)
          }
      }
      else
        if (data.devs.ap.includes(packet.bssid)) {
          packet.mac = packet.bssid
          packet.ssid = data.db[packet.bssid].ssid

          if(!data.db[packet.bssid].hosts.includes(packet.src)) {
            data.db[packet.bssid].hosts.push(packet.src)

            if(!data.db.hasOwnProperty(packet.src))
              data.db[packet.src] = newWifiDevice(packet)
        }
      }
    }*/

    if(data.db.hasOwnProperty(packet.mac)) {
      var output = []

      output = data.db[packet.mac].update(packet)
      data.sensors[sensor].update(packet)

      if(packet.type == 'ap')
        output.client.forEach(mac => {
          if(!data.db[packet.mac].hosts.includes(mac) && data.devs.sta.includes(mac)) {
            log(`Adding client ${mac} to ${packet.ssid}`)
            data.db[packet.mac].hosts.push(mac)
          }
        })

      if(output.lost.length || output.lastseen.length)
        log(`${output.dir} ${data.db[packet.mac].type.toUpperCase()} '${output.name}' ${output.action} from ${sensor} type ${data.db[packet.mac].vendorSm} rssi ${packet.rssi} seq ${packet.seq} ${output.lastseen}`)
      data.stats.packets += 1

    } else {
      error(`Capture: Unrecognized device or packet type: ${JSON.stringify(packet.rftype)} ${packet.mac}`)
      console.dir(packet)
      return
    }
  } catch (e) {
    error(`Decode Packet: ${e}`)
    data.stats.errors += 1
  }
}

function readSDRPacket(msg, id) {
  var packet = new rtlDevice(msg),
      sensor = msg.sensor,
      now = new Date()

  data.location = msg.location
  data.stats.rtl += 1
    if(!data.sensors.hasOwnProperty(sensor)) {
      log(`New sensor: ${sensor} at ${id}`)
      data.clients[id].name = sensor
      data.sensors[sensor] = new Sensor(packet)
      data.sensors[sensor].id = id
    }
    else
      data.sensors[sensor].update(packet)

  log(packet)
}

function syncDB() {
  // promise ..
  if(program.verbose)
    log(`syncing DB: ${Object.keys(data.db).length} devices`)
  store.sync(data.db, (err, docs) => {
    if(err)
      error(`Syncing: ${err}`)
    /*else {
      if(typeof docs === 'number')
        data.info.lastupdated += Object.keys(docs).length
      else if(typeof docs == 'object')
        data.info.lastadded += parseInt(docs)
    }*/
  })
}

function latest(since=cfg.ws.subscribe_interval) {
  var out = {}

  updateStats()

  Object.keys(data.db).forEach(k => {
    var dev = data.db[k]

    if(new Date().getTime() - new Date(dev.lastseen).getTime() <= since)
      out[k] = dev
  })

  return { sensors: data.sensors, info: data.info, stats: data.stats, db: out }
}



if(cfg.oui.update)
  fs.stat(path.join(cfg.baseDir,'data',cfg.oui.file), utils.updateOUI)

const wss = new WS.Server({ port: program.port })

log(`Listening on port ${program.port}`)

wss.on('connection', (ws, req) => {
  const ip = req.connection.remoteAddress
  const port = req.connection.remotePort

  const id = `${ip}_${port}`

  if(!data.clients.hasOwnProperty(id))
    data.clients[id] = { type: null, client: null, host: ip.replace('::ffff:',''), port: port,
                    firstseen: new Date(), lastseen: new Date() , timer: {} }


  log(`Connection from ${id}}`)

  ws.on('message', message => {
    const id = `${ws._socket._peername.address}_${ws._socket._peername.port}`

    try {
      var msg = JSON.parse(message)
    } catch (e) {
      error(`Bad message format from ${id}: ${message}`)
      return
    }

    if(data.clients[id].type === null) {
      if(msg.hasOwnProperty('sensor') && msg.hasOwnProperty('source'))
        data.clients[id].type = 'sensor'
      else
      if(msg.hasOwnProperty('client'))
        data.clients[id].type = 'client',
        data.clients[id].client = msg.client
    }

    data.clients[id].lastseen = new Date()

    if(msg.hasOwnProperty('type')) {
      if(msg.type == 'data' && msg.hasOwnProperty('source')) {
        if(msg.source == 'wifi')
          readWifiPacket(msg, id)
        else
        if(msg.source == 'sdr')
          readSDRPacket(msg, id)
      } else
      if(msg.type == 'log' && msg.hasOwnProperty('sensor') && msg.hasOwnProperty('data')) {
        msg.data.forEach(line => { log(`${msg.sensor}: ${line.log}`) })
        //log(`${msg.sensor}: ${JSON.stringify(msg.data)}}`)
      } else
      if (msg.type == 'status') {
        if(data.sensors.hasOwnProperty(msg.sensor)) {
          data.sensors[msg.sensor].info = msg.data.info
          data.sensors[msg.sensor].stats = msg.data.stats
          data.sensors[msg.sensor].osinfo = msg.data.osinfo
          data.sensors[msg.sensor].location = msg.location
          data.sensors[msg.sensor].config = msg.data.config
          data.sensors[msg.sensor].lastseen = new Date()
        } else {
          //error(`Unknown message ${msg.type} from ${msg.sensor} with length ${msg.data.length}`)
        }
      } else
      if (msg.type == 'time') {
        // if arg, do smt
        ws.send(JSON.stringify({ type: time, data: new Date() }))
      }
    } else
    if(msg.hasOwnProperty('cmd')) {
      if(msg.cmd == 'channels') {
        if(msg.hasOwnProperty('sensor')) {
          log(`Received channel list from ${id}: ${msg.data}`)
          var channels = data.channels.concat(msg.data)
          data.channels = [...new Set(channels)]
        }
        else {
          log(`Sending channel list to ${id}`)
          ws.send(JSON.stringify({type: 'channels', data: data.channels }))
        }
      }
      else
      if (msg.cmd == 'latest') {
        var duration

        if(msg.hasOwnProperty('arg'))
          duration = parseInt(msg.arg)
        else
          duration = cfg.ws.subscribe_interval

        ws.send(JSON.stringify({ type: 'latest', location: decycle(data.location),
                                 time: new Date(), data: decycle(latest(duration))}))
      } else
      if (msg.cmd == 'status') {
        updateStats()
        ws.send(JSON.stringify({ type: 'status', time: new Date(),
                                 data: { sensors: decycle(data.sensors), stats: decycle(data.stats), info: decycle(data.info), location: decycle(data.location), clients: decycle(data.clients)} }))
      } else
      if (msg.cmd == 'sensors') {
        updateStats()
        ws.send(JSON.stringify({ type: 'status', time: new Date(), data: { sensors: decycle(data.sensors) } } ))

      } else
      if (msg.cmd == 'dump') {
        updateStats()
        // maybe foreach ws.send maxpktsize ..
        ws.send(JSON.stringify({ type: 'dump', time: new Date(), data: { db: decycle(data.db), sensors: decycle(data.sensors),
                                                                         stats: data.stats, info: data.info, location: data.location  } }))
      } else
      // find mac=xxx, ssid=xxx
      if (msg.cmd == 'find') {
        if(!msg.hasOwnProperty('arg') || !msg.arg.search('=')) {
          error(`Bad find command from ${id}`)
          return
        }

        var args = msg.arg.split('=')

        var sendResults = (err, res) => {
          if(err === null)
            ws.send(JSON.stringify({ type: 'result', field: args[0], query: args[1], time: new Date(), data: res }))
          else {
            ws.send(JSON.stringify({ type: 'result', field: args[0], query: args[1], time: new Date(), data: err }))
            error(`Search: ${err}`)
          }
        }

        store.find(args[0], args[1], sendResults)
      } else
      if (msg.cmd == 'subscribe') {
        var subType
        log(`New Subscriber: ${id}`)

        // subscribe to latest, logs, status, location, etc
        if(msg.hasOwnProperty('type'))
          subType = msg.type
        else
          subType = 'latest'

        if(msg.hasOwnProperty('arg')) {
          if(['logs','latest','status','location'].includes(msg.arg))
            subType = msg.arg
          else
            duration = parseInt(msg.arg)
        }
        else
          duration = cfg.ws.subscribe_interval 

        if(subType == 'logs') {
          data.clients[id].timer.logs = setInterval(() => { 
            const id = `${ws._socket._peername.address}_${ws._socket._peername.port}`

            if (ws.readyState === WS.OPEN) {
              var lines = lastlog()
              if(lines.length)
                ws.send(JSON.stringify({ type: 'log', data: lines }))
            } else {
              //debug(`Connection closed, terminating log subscription to ${id}`)
              //console.dir(data.clients)
              clearInterval(data.clients[id].timer.logs)
              delete data.clients[id].timer.logs
              ws.terminate()
            }
          }, cfg.ws.subscribe_logs)
        } else
        if(subType == 'latest') {
          data.clients[id].timer.latest = setInterval(() => { 
            const id = `${ws._socket._peername.address}_${ws._socket._peername.port}`

            if (ws.readyState === WS.OPEN) {
              var output = latest()
              ws.send(JSON.stringify({ type: 'latest', time: new Date(),
                                       location: data.location,
                                       data: decycle(output)}))
            } else { //debug(`Connection closed, terminating latest subscription to ${id}`)
              //console.dir(data.clients)
              clearInterval(data.clients[id].timer.latest)
              delete data.clients[id].timer.latest
              ws.terminate()
            }
          }, cfg.ws.subscribe_interval) 

          var output = latest()
          ws.send(JSON.stringify({ type: 'latest', time: new Date(),
                                   location: data.location,
                                   data: decycle(output) }))

        }
      } else
      if (msg.cmd == 'unsubscribe') {
        clearInterval(data.clients[id].timer.latest)
      }

      if(data.clients[id].client == 'sigmon.command.client') {
        delete data.clients[id]
        ws.terminate()
      }
    } else {
      error(`Invalid packet: ${message}`)
    }
  })
})

function cleanExit(reason=420) {
  syncDB()

  console.warn(`exiting: ${reason}`)

  wss.close()

  error(`Exiting by request - ${reason}.`)
  log('Good bye.')

  process.exit(reason)
}

if(cfg.db.enabled)
  syncTimer = setInterval(syncDB, program.syncInterval)

cleanup(cleanExit)
