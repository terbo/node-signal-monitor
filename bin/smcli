#!/usr/bin/env node
'use strict';

/*# first page
#  status | keys
#  device table | device info
#  log
# second page
#  hosts/channel
#  channel graph
# third page
#  packets per sensor
#  packets per channel
#  packets per minute
#  packets per hour ...
# fourth page
#  full status table
#  status of each sensor
#  status of database
#  connected clients
# fifth page?
# all ssids/grouped clients
# settings
*/

var cfg = require('../etc/config')

module.paths.unshift(cfg.baseDir+'lib')

const wifiChannels = require('wifichannel')

const extend   = require('extend'),
      sortkeys = require('sort-keys'),
      sprintf  = require('sprintf-js').sprintf,
      process  = require('process'),
      program  = require('commander'),
       player  = require('node-wav-player'),
           hmn = require('human-number'),
           RWS = require('reconnecting-websocket'),
            WS = require('ws')

require('console-stamp')(console, { pattern: 'HH:MM:ss' })


program.option('-s, --server <server>', 'sigmon server to connect to',cfg.sensor.ws.hostname)
program.option('-p, --port <port>', 'port to connect to',cfg.sensor.ws.port)

program.parse(process.argv)

var blessed = require('blessed'),
     contrib = require('blessed-contrib'),
     screen = blessed.screen({ debug: true,
                               smartCSR: true,
                               dockBorders: true,
                               ignoreDockContrast: true,
                               autoPadding: true
                              })
var devices = {},
    packetGraph = {},
    channelGraph = []

var sortType     = 2,
    filterType   = 0,
    reverse      = true,
    displayType  = 1,
    displayTypes = ['all','ap','sta'],
    redraw = true,
    drawJSON = false,
    gpsLock = false

Object.keys(wifiChannels.frequencyMap).forEach(f => {
  channelGraph.push(0)
})


//               //
/*               */
 // Sort Funcs  //
/*               */
//               //


const sortFn = [ sortByType, sortVendor, sortRSSI, sortSSID, sortChannel, sortLast, sortClients, sortBytes ]
const sortTypes = ['Type', 'Vendor', 'RSSI', 'SSID', 'Channel','Lastseen','STAs','Bytes']
const filterTypes = ['None','Proximity','Far','OUI','Unknown','Regular','Recent', 'Alert'] //,'Owned']

function sortByType(a,b) {
  if(devices[a].type > devices[b].type)
    if(reverse) return -1
    else return 1
  if(devices[a].type < devices[b].type)
    if(reverse) return 1
    else return -1
  return 0
}

function sortClients(a,b) {
  if(reverse)
    return devices[b].hosts.length - devices[a].hosts.length
  else
    return devices[a].hosts.length - devices[b].hosts.length
}

function sortFirst(a,b) {
  if(reverse)
    return new Date(devices[b].firstseen).getTime() - new Date(devices[a].firstseen).getTime()
  else
    return new Date(devices[a].firstseen).getTime() - new Date(devices[b].firstseen).getTime()
}

function sortBytes(a,b) {
  if(reverse)
    return devices[b].totalBytes - devices[a].totalBytes
  else
    return devices[a].totalBytes - devices[b].totalBytes
}

function sortLast(a,b) {
  if(reverse)
    return new Date(devices[b].lastseen).getTime() - new Date(devices[a].lastseen).getTime()
  else
    return new Date(devices[a].lastseen).getTime() - new Date(devices[b].lastseen).getTime()
}

function sortSSID(a,b) {
  if(devices[a].ssid.toUpperCase() > devices[b].ssid.toUpperCase())
    if(reverse) return -1
    else return 1
  
  if(devices[a].ssid.toUpperCase() < devices[b].ssid.toUpperCase())
    if(reverse) return 1
    else return -1
  return 0
}

function sortChannel(a,b) {
  if(reverse)
    return devices[b].channel - devices[a].channel
  else
    return devices[a].channel - devices[b].channel
}

function sortRSSI(a,b) {
  if(reverse)
    return devices[b].rssi - devices[a].rssi
  else
    return devices[a].rssi - devices[b].rssi
}

function sortVendor(a,b) {
  if(devices[a].vendor.toUpperCase() > devices[b].vendor.toUpperCase())
    if(reverse) return 1
    else return -1
  if(devices[a].vendor.toUpperCase() < devices[b].vendor.toUpperCase())
    if(reverse) return -1
    else return 1
  return 0
}


/*               */
/*               */
 //   Output    //
/*               */
/*               */


function playwav(wav) {
  if(cfg.console.sound) {
    //status1.log(`Playing '${wav}.wav'`)
    player.play({path: `./data/wav/${wav}.wav`}).then(() => {
      }).catch((error) => { status1.log(`Error playing sound: ${error}`) })
  }
}

function update() {
  const headers = ['Type', 'Sensors', 'MAC', 'SSID', 'RSSI', 'Ch', 'Vendor','Last Seen','STAs','Bytes']
  
  var rows = [],
      now = new Date(),
      nowH = now.getHours().toString().padStart(2,0) + ':' +
             now.getMinutes().toString().padStart(2,0) + ':' +
             now.getSeconds().toString().padStart(2,0),
      nowS = now.getTime()
  
  Object.keys(sortkeys(devices,{compare: sortFn[sortType]})).forEach(mac => {
    var dev = devices[mac],
        sensors = '',
        lastseen = new Date(dev.lastseen).getTime(),
        firstseen = new Date(dev.firstseen).getTime()
    dev.tags = []

    if(cfg.sensor.alert.includes(mac)) { // that wascally wabbit...
      playwav('alert')
      status1.log(`${mac} seen @ ${now}`)
      dev.tags.push('alert')
    } 
    
    if(cfg.sensor.ignore.includes(mac))
      return

    dev.sensors.forEach(sensor => {
      if(!packetGraph.hasOwnProperty(sensor))
        packetGraph[sensor] = { title: sensor, style: { line: colors.pop()}, x: [], y: [] }

      // get the index of the last data column
      var lastIdx = packetGraph[sensor].x.length - 1

      // if(packetGraph[sensor].x[lastIdx] != nowH)
        packetGraph[sensor].x.push(nowH)

      var lastCol = packetGraph[sensor].y.length - 1

      // now increase the number of packets
      if(lastCol < lastIdx)
        packetGraph[sensor].y[lastIdx] = 1
      else
        packetGraph[sensor].y[lastIdx] += 1
    })

    if(dev.channel && dev.channel >= 1 && dev.channel <= 11) {
      if(dev.type == 'ap')
        channelGraph[dev.channel - 1] += 1
     } else // fudge, shouldn't be needed
       dev.channel = 13

    if(filterTypes[filterType] == 'Recent' && (nowS > (lastseen + cfg.console.device_timeout)))
      return
    else
      dev.tags.push('recent')

    if(displayTypes[displayType] == 'ap' && dev.type == 'sta')
      return
    
    if(displayTypes[displayType] == 'sta' && dev.type == 'ap')
      return
    
    if(carousel.currPage == 0) {
      
      if(nowS > (firstseen + cfg.console.device_timeout))
        dev.tags.push('new')
      
      else if(((firstseen - nowS) > 30000) && (now < (lastseen + 3000)))
        dev.tags.push('session')

      if(dev.rssi > cfg.console.close_rssi)
        dev.tags.push('proximity')
      else if(dev.rssi < cfg.console.far_rssi)
        dev.tags.push('far')
      
      if(dev.vendor == 'Unknown')
        dev.tags.push('unknown')
      else
        dev.tags.push('oui')
     
      if(dev.sensors.length > 1)
        sensors = `${dev.sensors[0]},+${(dev.sensors.length) - 1}`
      else
        sensors = dev.sensors[0]

      if(filterType === 0 || dev.tags.includes(filterTypes[filterType].toLowerCase()))
        try {
          rows.push([ dev.type.toUpperCase(), sensors, dev.mac, dev.ssid.substr(0,24).padEnd(24,' '), dev.rssi, dev.channel,
                    dev.vendorSm, new Date(lastseen).toTimeString().split(' ')[0], dev.hosts.length, hmn(dev.totalBytes.toPrecision(3))])
        } catch(e) {
          console.log(e)
        }
    }
  })
  
  if(carousel.currPage == 0 && status_info) {
    var out,
        out2,
        mem = 0,
        cpu = 0,
        dbsize = 0,
        running = 0,
        loc = {}

    mem = hmn(status_info[0].memory.rss.toPrecision(3))
    dbsize = hmn(status_info[0].dbsize.toPrecision(3)) 
    
    if(!gpsLock && (status_info[3].sats >= 5)) {
      playwav('gpslock')
      gpsLock = true
    }
    else if (gpsLock && (status_info[3].sats <= 4)) {
      playwav('gpslost')
      gpsLock = false
    }
      
    out = ` Total APs: __${status_info[0].aps}__ STAs: __${status_info[0].stas}__` +
          ` (Showing ${Object.keys(devices).length}) ` +
          ` Packets: __${hmn(status_info[0].packets.toPrecision(3))}__\n` +
           ` Showing ${displayTypes[displayType].toUpperCase()} Filtering ${filterTypes[filterType]} ` +
           `sorting${reverse ? ' reverse ' : ' '}by ${sortTypes[sortType]}\n` +
           `${ !redraw ? '{bold}{red-fg}\t\t\t\t\tPaused updating{/}{/}' : ''}`

    loc.lon = status_info[3].lon || 0
    loc.lat = status_info[3].lat || 0
    loc.sats = status_info[3].sats || 0

    if(loc.lon && loc.lon !== 0)
      loc.lon = Number(loc.lon).toPrecision(7)
    
    if(loc.lat && loc.lat !== 0)
      loc.lat = Number(loc.lat).toPrecision(7)

    out2 = ` Lon/Lat: __${loc.lon}__, __${loc.lat}__` +
           `  Sats: __${loc.sats}__\n` +
           ` Mem: {bold}${mem}{/} DB: {bold}${dbsize}{/}\n\n` +
           ` Server: {bold}${status_info[1].hostname}{/}:{bold}${status_info[1].port}` +
           ` / {green-fg}${status_info[1].version}{/}`

    running = status_info[0].uptime
    
    var sensors = '',
            now = new Date()
    
    Object.keys(status_info[2]).forEach(sensor => {
      sensors += `__${sensor}__ (${hmn(status_info[2][sensor].packets.toPrecision(3))}) `
      var last = status_info[2][sensor].lastseen
      var lastseen = now - last
      
      if(lastseen > 60000)
        sensors += '(DC) '
    })
    
    out += `\n ${sensors}`
    
    status1_markdown.setMarkdown(out)
    status2_markdown.setMarkdown(out2)
  }
  
  if(redraw && carousel.currPage == 1) {
    if(Object.keys(packetGraph).length)
      packet_graph.setData(Object.values(packetGraph))
    
    try {
      channel_bar.setData({
        titles: Object.values(wifiChannels.frequencyMap),
        data: channelGraph })
    }
    catch (e) {
      console.log(e)
      console.table(channelGraph)
    }
  } 
  
  if(redraw && carousel.currPage == 0)
    try {
      deviceTable.setData({ headers: headers, data: rows})
    }
    catch (e) {
      console.error(e)
      console.table(rows)
      do_exit()
    }

  screen.render()
}

function do_search(err, data) {
  if (err) throw err;
  
  searchBox.hide()
  var re = new RegExp(data,'i')
  var matches = []
 
  // # of table entries likely less than devices.. redundant though
  /*Object.keys(deviceTable.rows.children).forEach(i => {
    var row = deviceTable.rows.children[i]

    if(row.content.match(re)) {
      var mac = row.content.split(/\s+/)[2]*/
    Object.keys(devices).forEach((mac) => { 
      Object.keys(devices[mac]).forEach((field) => {
        try{if(devices[mac][field].toString().match(re) && (!['vendorSm','_id'].includes(field)))
          matches.push(`${mac}: ${field} ${devices[mac][field]}`)} catch(e) { status1.log(mac) }
      })
    })

  if(Object.keys(matches).length) {
    status1.log(`Found ${matches.length} matches for {bold}${data}{/}`)
    
    searchBox.hide()
    searchResults.setItems(matches)
    searchResults.show()
    searchResults.focus()
    screen.render()
  }
}


function do_exit(s) {
  screen.destroy()
  screen.program.clear()
  screen.program.disableMouse()
  screen.program.showCursor()
  screen.program.normalBuffer()
  ws.close()
  
  process.exit(2)
}


/*              */
/*              */
 //  Keybinds  //
/*              */
/*              */


screen.key(['escape', 'q', 'C-c'], do_exit)

screen.key('C-d', () => { ws.send(JSON.stringify({'cmd': 'dump'})) })

screen.key('C-s', () => {
  cfg.console.sound = !cfg.console.sound
  status1.log('Sound ' + (cfg.console.sound ? 'enabled' : 'disabled'))
})

screen.key(['s'], (ch, key) => {
  if(carousel.currPage !== 0)
    return

  sortType = (sortType < Object.keys(sortFn).length - 1) ? sortType + 1 : 0
  
  status1.log(`Sorting by ${sortTypes[sortType]}`)
  update()
})

screen.key(['a'], (ch, key) => {
  if(carousel.currPage !== 0)
    return 
  
  displayType = displayType < displayTypes.length - 1? displayType + 1 : 0
  
  status1.log(`Displaying ${displayTypes[displayType].toUpperCase()}`)
  update()
})

screen.key(['r'], (ch, key) => {
  if(carousel.currPage !== 0)
    return 
  reverse = !reverse
  update()
})

screen.key(['f'], (ch, key) => {
  if(carousel.currPage !== 0)
    return

  filterType = filterType < filterTypes.length - 1? filterType + 1 : 0
  status1.log(`Filtering ${filterTypes[filterType]}`)
  update()
})

screen.key(['i'], (ch, key) => {
  if(carousel.currPage !== 0)
    return

  drawJSON = !drawJSON
  
  if(drawJSON)
    status1.log('Drawing JSON in Info Window')
  else
    status1.log('Drawing Markdown in Info Window')
  
  screen.render()
})

screen.key(['m'], (ch, key) => {
  if(carousel.currPage !== 0)
    return
  if(searchResults.focused) {
    searchResults.hide()
    deviceTable.show()
    deviceTable.focus()
  }
  else
    searchResults.show()
    searchResults.focus()
  screen.render()
})

screen.key(['z'], (ch, key) => {
  if(carousel.currPage !== 0)
    return 
  
  redraw = !redraw
  
  if(redraw)
    status1.log('Redraw enabled')
  else
    status1.log('Redraw disabled')
  
  update()
})

screen.key('h', () => {
  if(helpBox.focused) {
    helpBox.hide()
    deviceTable.show()
    deviceTable.focus()
  } else {
    status1.log('Showing help')
    helpBox.show()
    helpBox.focus()
  }
  screen.render()
})

screen.key('/', () => {
  searchBox.show()
  searchBox.focus()
  searchBox.input('Search:', '', do_search)
})

screen.key(['tab'], () => {
  if(carousel.currPage == (carousel.pages.length - 1)) {
    carousel.home()
    deviceTable.focus()
  }
  else
    carousel.next()
  
  redraw = true 
  update()
})

screen.key(['1','2'], (ch, key) => {
  carousel.currPage = ch - 1
  carousel.move()
  
  redraw = true 
  update()
})


//               //
/*               */
 //  Web Socket //
/*               */
//               //


const ws = new WS(`ws://${program.server}:${program.port}/ws`, [], { WebSocket: WS })

ws.addEventListener('open', () => {
  status1.log('Connected to websocket ' + program.server)
  ws.send(JSON.stringify({'cmd': 'subscribe'}))
})

ws.addEventListener('message', message => {
  var msg = JSON.parse(message.data),
    oldnum = Object.keys(devices).length,
    newnum = Object.keys(msg.data.db).length,
    total = 0

  //status1.log(`Devices: ${oldnum}`)
  //status1.log(`msg.data.db ${newnum}`)

  extend(true, devices, msg.data.db)
  total = Object.keys(devices).length

  if(total > oldnum)
    playwav('packet')

  status_info  = [msg.data.stats, msg.data.info, msg.data.sensors, msg.data.location || msg.location]
 
  //status1.log(`Devices After: ${total}`)

  update()
})

ws.addEventListener('error', e => {
  status1.log(`WS Client: ${e.error}`)
})

function drawInfo(mac) {
  var dev = devices[mac],
      out
  
  if(!drawJSON) {
      out =  `${dev.mac} - ${dev.vendor}`
      out += `\n\nFirst seen: ${dev.firstseen.toLocaleString()}\n`
      out += `Last seen: ${new Date(dev.lastseen).toLocaleString()}`
      out += `Last RSSI/Seq# ${dev.rssi}/${dev.seq}\n`
      out += `\nTotal Packets/Bytes: ${hmn(dev.totalPackets.toPrecision(3))}/${hmn(dev.totalBytes.toPrecision(3))}\n`
      out += `\n`

    if(dev.type == 'ap')
      out += `Clients:\n`
    else
      out += `Probed SSIDs:\n`

      dev.hosts.forEach(h => {
        if(dev.type == 'ap' && devices.hasOwnProperty(h)) {
          out += `* __${devices[h].mac}__  ${devices[h].vendorSm} (${devices[h].rssi})\n`
          out += `* . Last Seen: ${new Date(devices[h].lastseen).toLocaleString()}\n`
        } else {
          out += `* __${h}__\n`
        }
      })
  } else
    out = JSON.stringify(dev,null,2)

  info_markdown.setMarkdown(out)
	status1.log(`Showing info for {bold}${mac}{/}`)
  update()
}

    //             //
   /*             */
  //  Widgets    //
 /*             */
//             //

var colors = ['yellow','cyan','red','white','blue','green']

var devices_grid, deviceTable, graphics_grid, status1_markdown, status2_markdown, device_markdown, channel_graph, packet_graph
var status1, status2, server_log, packet_graph, channel_bar, device_markdown, status_info, keys, info_markdown

// Dimensions for table - yaml?
const dim = {
  scr:  {r: 10, c: 11},
  status1:  {h: 0, w: 0, x: 1, y: 6},
  status2:  {h: 0, w: 5, x: 1, y: 8},
  devTable:  {h: 1, w: 0, x: 8, y: 10},
  chanbar:  {h: 5, w: 11, x: 0, y: 0},
  pktGraph:  {h: 5, w: 0, x: 5, y: 11},
  logger:  {h: 1, w: 8, x: 9, y: 0},
  info: {h: 10, w: 3, x: 0, y: 8},
  devTbCols: [4, 11, 18, 24, 4, 3, 11, 11, 5, 12],
  devTb: {w: '60%', h: '50%'},
  sBox: {w: '50%', h: 'shrink'},
  sRes: {w: '50%', h: 'shrink'},
}

function devices_page() {
  devices_grid = new contrib.grid({rows: dim.scr.r, cols: dim.scr.c, screen: screen})

  status1_markdown = devices_grid.set(dim.status1.h, dim.status1.w, dim.status1.x,dim.status1.y, contrib.markdown, {
    tags: true,
    interactive: false
  })
  
  status2_markdown = devices_grid.set(dim.status2.h, dim.status2.w, dim.status2.x,dim.status2.y, contrib.markdown, {
    tags: true,
    interactive: false
  })

  deviceTable = devices_grid.set(dim.devTable.h, dim.devTable.w, dim.devTable.x,dim.devTable.y, contrib.table,
     { keys: true,
       mouse: true,
       vi: true,
       tags: true,
       fg: 'white',
       selectedFg: 'white',
       selectedBg: 'blue',
       label: 'Active',
       noCellBorders: true,
       interactive: true,
       width: dim.devTb.w,
       height: dim.devTb.h,
       border: {
        type: 'ascii',
        fg: 'cyan'},
       columnSpacing: 3, // in chars
       columnWidth: dim.devTbCols })
  
  deviceTable.rows.on('select',(i,idx) => {
    try {
      var selected = i.content.match(/[0-9a-f]{1,2}([\.:-])(?:[0-9a-f]{1,2}\1){4}[0-9a-f]{1,2}/)
      drawInfo(selected[0])
    } catch (e) {console.log(e)}
  })

  info_markdown = devices_grid.set(dim.info.x,dim.info.y, dim.info.h, dim.info.w, contrib.markdown,
   {
     label: 'info',
     tags: true
  }
 )

  status1 = devices_grid.set(dim.logger.x,dim.logger.y,dim.logger.h,dim.logger.w, contrib.log,
      { fg: 'green',
        padding: 1,
        tags: true,
        selectedFg: 'green',
        label: 'log'})
  
  deviceTable.show()
  deviceTable.focus()
}

function graphics_page() {
  graphics_grid = new contrib.grid({rows: dim.scr.r, cols: dim.scr.c, screen: screen})
  
  channel_bar = graphics_grid.set(dim.chanbar.x,dim.chanbar.y,dim.chanbar.h,dim.chanbar.w, contrib.bar,
       { label: 'Channel Usage',
         barWidth: 10,
         barSpacing: 10,
         xOffset: 10,
         maxHeight: 30
       })

  packet_graph = graphics_grid.set(dim.pktGraph.h, dim.pktGraph.w, dim.pktGraph.x, dim.pktGraph.y, contrib.line,
       { style:
         { line: 'yellow',
           text: 'green',
           baseline: 'black'},
         xLabelPadding: 4,
         xPadding: 4,
         showLegend: true,
         wholeNumbersOnly: true, //true=do not show fraction in y axis
         label: 'Packets'
        })
}

var searchResults = blessed.list({  
  parent: screen,
  title: 'search results',
  width: '40%',
  height: '30%',
  top: 'center',
  left: 'center',
  align: 'center',
  fg: 'white',
  border: {
    type: 'line'
  },
  selectedBg: 'blue',
  mouse: true,
  keys: true,
  vi: true,
  tags: true,
})

searchResults.on('select',(i,idx) => {
  try {
    var mac = i.content.split(': ')[0]
    drawInfo(mac)
    searchResults.hide()
    deviceTable.focus()
    screen.render()
  } catch (e) { console.log(e)}
})

var searchBox = blessed.prompt({
  parent: screen,
  left: 'center',
  top: 'center',
  width: dim.sBox.w,
  height: dim.sBox.h,
  border: 'line'
})

var helpText,
    helpBox = blessed.box({
    parent: screen,
    top: 'center',
    left: 'center',
    width: 'shrink',
    draggable: true,
    height: 15,
    padding: 1,
    tags: true,
    border: {
      type: 'ascii',
      fg: 'green'
      },
    })

// Workaround for centering shrunken box.
  helpBox.on('prerender', function() {
  var lpos = helpBox._getCoords(true)
  if (lpos) {
    helpBox.rleft = (screen.width - (lpos.xl - lpos.xi)) / 2 | 0
  }
})

helpText = `{bold}sigmon console version ${cfg.version}{/}` +
           '\n\n' +
           '[tab] change view [a] display type\n' +
           '[s] sort [r] reverse [enter] info\n' +
           '[f] filter [z] pause [q] quit' +
           '\n\n' +
           'Control-D: Request ALL data from server\n' +
           'Control-S: Toggle Sound\n\n\n' +
           'press enter to exit this help screen'

helpBox.setContent(helpText)

helpBox.on('keypress', () => {
  helpBox.hide()
  deviceTable.show()
  deviceTable.focus()
  screen.render()
})
  
var carousel = new contrib.carousel( [devices_page, graphics_page]
                                     , { screen: screen
                                     , interval: 0
                                     , controlKeys: false })

carousel.start()

// all this needs to go in the page...
screen.append(helpBox)
screen.append(searchBox)
screen.append(searchResults)
searchResults.hide()

helpBox.focus()

setTimeout(() => { helpBox.hide() }, 1000)
